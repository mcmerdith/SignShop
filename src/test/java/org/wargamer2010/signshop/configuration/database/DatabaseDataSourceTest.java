package org.wargamer2010.signshop.configuration.database;

import junit.framework.TestCase;
import org.bukkit.Material;
import org.bukkit.inventory.ItemStack;
import org.junit.*;
import org.sqlite.SQLiteDataSource;
import org.wargamer2010.signshop.SignShop;
import org.wargamer2010.signshop.configuration.Storage;
import org.wargamer2010.signshop.configuration.database.queries.QueryInsert;
import org.wargamer2010.signshop.configuration.database.queries.QuerySelect;

import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.*;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.logging.Level;
import java.util.stream.Collectors;

import static org.wargamer2010.signshop.configuration.database.SQL_Schema.*;

public class DatabaseDataSourceTest {
    private DatabaseDataSource source;

    @Before
    public void setUp() throws Exception {

        // Set up a test database
        SignShop.log("Setting up connection", Level.INFO);

        SQLiteDataSource datasource = new SQLiteDataSource();
        datasource.setUrl("jdbc:sqlite:ss_test.sqlite.db");

        source = new DatabaseDataSource(datasource);
        Storage.setSource(source);

        // TABLE TIME >:)
        try (Connection connection = source.getConnection()) {
            SQL_Schema.dropTable(connection, SQL_Schema.TABLE_SELLERS.tableName());
            SQL_Schema.dropTable(connection, SQL_Schema.TABLE_ACTIVATABLES.tableName());
            SQL_Schema.dropTable(connection, SQL_Schema.TABLE_CONTAINABLES.tableName());
            SQL_Schema.dropTable(connection, SQL_Schema.TABLE_ITEMS.tableName());
        }

        Assert.assertTrue("Failed to initialize tables", initTables());
    }

    @After
    public void tearDown() throws Exception {
        source.dispose();
    }

    public void resetDB() {

    }

    @Test
    @Ignore
    public void testAdapter() {
        // Must have a database
        Assert.assertTrue("Storage is not a database", Storage.get() instanceof DatabaseDataSource);

        // Fake seller data
        Map<String, Object> seller = new HashMap<>();
        seller.put(TABLE_SELLERS.SHOPWORLD.columnName(), "world");
        seller.put(TABLE_SELLERS.OWNER.columnName(), "mcmerdith");
        seller.put(TABLE_SELLERS.SIGN.columnName(), "L0.0x1.0y2.0z");
        seller.put(TABLE_SELLERS.MISC.columnName(), "hmmm, very odd");

        List<Map<String,Object>> activators = new ArrayList<>();
        activators.add(new HashMap<>(Collections.singletonMap(TABLE_ACTIVATABLES.ACTIVATABLE.columnName(), "0AL123x456y789")));
        activators.add(new HashMap<>(Collections.singletonMap(TABLE_ACTIVATABLES.ACTIVATABLE.columnName(), "1AL123x456y789")));
        activators.add(new HashMap<>(Collections.singletonMap(TABLE_ACTIVATABLES.ACTIVATABLE.columnName(), "2AL123x456y789")));

        List<Map<String,Object>> containers = new ArrayList<>();
        containers.add(new HashMap<>(Collections.singletonMap(TABLE_CONTAINABLES.CONTAINABLE.columnName(), "0CL123x456y789")));
        containers.add(new HashMap<>(Collections.singletonMap(TABLE_CONTAINABLES.CONTAINABLE.columnName(), "1CL123x456y789")));
        containers.add(new HashMap<>(Collections.singletonMap(TABLE_CONTAINABLES.CONTAINABLE.columnName(), "2CL123x456y789")));


        List<Map<String,Object>> items = new ArrayList<>();
        items.add(new HashMap<>(Collections.singletonMap(TABLE_ITEMS.ITEM.columnName(), new ItemStack(Material.STONE, 16))));

        // some lazy injection ;)
        Arrays.asList(activators, containers, items).forEach((list) -> list.forEach((data) -> data.put("seller_sign", seller.get("sign"))));

        // Begin
        try (Connection connection = ((DatabaseDataSource) Storage.get()).newConnection()) {
            // Start a new transaction
            connection.setAutoCommit(false);

            // INSERT seller
            QueryInsert insertSeller = new QueryInsert(seller);

            try (PreparedStatement insertStatement = insertSeller.prepareStatement(connection, "sellers")) {
                Assert.assertEquals("Incorrect number of rows affected by seller insertion", 1, insertStatement.executeUpdate());

                ResultSet insertResults = insertStatement.getGeneratedKeys();

                // Must have successfully inserted the data
                Assert.assertTrue("Couldn't get the autogenerated seller key", insertResults.next());
            } catch (SQLException e) {
                DatabaseDataSource.sqlError(e);
                Assert.fail("Seller insertion failed");
            }

            // Prepare the associated tables

//            List<QueryInsert> insertRelatedContainers = SQLHelper.rowsWithSellerIdForeignKey(seller_id, TABLE_CONTAINABLES.CONTAINABLE.columnName(), containers).stream().map(QueryInsert::new).collect(Collectors.toList());
//            List<QueryInsert> insertRelatedActivators = SQLHelper.rowsWithSellerIdForeignKey(seller_id, TABLE_ACTIVATABLES.ACTIVATABLE.columnName(), activators).stream().map(QueryInsert::new).collect(Collectors.toList());
            List<QueryInsert> insertRelatedContainers = containers.stream().map(QueryInsert::new).collect(Collectors.toList());
            List<QueryInsert> insertRelatedActivators = activators.stream().map(QueryInsert::new).collect(Collectors.toList());

            // INSERT related rows
            AtomicBoolean fail = new AtomicBoolean();

            insertRelatedContainers.forEach((containerQuery) -> {
                try (PreparedStatement containerStatement = containerQuery.prepareStatement(connection, TABLE_CONTAINABLES.tableName())) {
                    // Must insert a column
                    Assert.assertEquals("Incorrect number of rows affected by container insertion", 1, containerStatement.executeUpdate());

                } catch (SQLException e) {
                    DatabaseDataSource.sqlError(e);
                    fail.set(true);
                }
            });

            insertRelatedActivators.forEach((activatorQuery) -> {
                try (PreparedStatement activatorStatement = activatorQuery.prepareStatement(connection, TABLE_ACTIVATABLES.tableName())) {
                    // Must insert a column
                    Assert.assertEquals("Incorrect number of rows affected by activator insertion", 1, activatorStatement.executeUpdate());
                } catch (SQLException e) {
                    DatabaseDataSource.sqlError(e);
                    fail.set(true);
                }
            });

            // Finish the transaction
            if (fail.get()) {
                // If any data failed to save, rollback the transaction
                connection.rollback();
            } else {
                // All good, commit the transaction
                connection.commit();
            }

            connection.setAutoCommit(true);

            /*
            VALIDATE
             */

            QuerySelect selectSeller = new QuerySelect(TABLE_SELLERS.allColumnNames());

            selectSeller.joinTo(TABLE_ACTIVATABLES.tableName(), "INNER", "sign", "seller_sign", Arrays.asList(TABLE_ACTIVATABLES.ID.columnName(), TABLE_ACTIVATABLES.ACTIVATABLE.columnName()));
            selectSeller.joinTo(TABLE_CONTAINABLES.tableName(), "INNER", "sign", "seller_sign", Arrays.asList(TABLE_CONTAINABLES.ID.columnName(), TABLE_CONTAINABLES.CONTAINABLE.columnName()));

            try (PreparedStatement selectStatement = selectSeller.prepareStatement(connection, "sellers")){
                ResultSet results = selectStatement.executeQuery();

                List<String> output = new ArrayList<>();

                // temp vars
                List<String> rowOutput = new ArrayList<>();

                // for each row
                while (results.next()) {
                    try {
                        rowOutput.add(columnValueString("shopworld", results.getString(1)));
                        rowOutput.add(columnValueString("owner", results.getString(2)));
                        rowOutput.add(columnValueString("sign", results.getString(3)));
                        rowOutput.add(columnValueString("misc", results.getString(4)));
                        rowOutput.add(columnValueString("activatable.id", results.getString(5)));
                        rowOutput.add(columnValueString("activatable", results.getString(6)));
                        rowOutput.add(columnValueString("containable.id", results.getString(7)));
                        rowOutput.add(columnValueString("containable", results.getString(8)));
                    } catch (SQLException e) {
                        DatabaseDataSource.sqlError(e);
                    } finally {
                        output.add(String.join(", ", rowOutput));
                        rowOutput.clear();
                    }
                }

                output.forEach(System.out::println);
            } catch (SQLException e) {
                DatabaseDataSource.sqlError(e);
                Assert.fail("Error in Select statement");
            }
        } catch (SQLException e) {
            DatabaseDataSource.sqlError(e);
            Assert.fail("Failed to connect to database");
        }
    }

    private static String columnValueString(String column, Object value) {
        return String.format("%s: %s", column, (value == null) ? "null" : value.toString());
    }

    @Test
    public void testLoad() {

    }
//
//    public void testSave() {
//    }
//
//    public void testShopCount() {
//    }
//
//    public void testAddSeller() {
//    }
//
//    public void testUpdateSeller() {
//    }
//
//    public void testGetSeller() {
//    }
//
//    public void testGetSellers() {
//    }
//
//    public void testRemoveSeller() {
//    }
//
//    public void testCountLocations() {
//    }
//
//    public void testGetSignsFromHolder() {
//    }
//
//    public void testGetShopsByBlock() {
//    }
//
//    public void testGetShopsWithMiscSetting() {
//    }
}